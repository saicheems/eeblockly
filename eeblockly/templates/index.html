<html>
<head>
  <meta charset="utf-8">
  <script src="https://unpkg.com/split.js/dist/split.min.js"></script>
  <script src="/static/js/blockly_compressed.js"></script>

  <link rel="stylesheet" href="static/css/style.css">
  <link rel="stylesheet" href="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.css">
</head>
<body>
  <div id="left-pane" class="split split-horizontal">
    <div id="map"></div>
  </div>
  <div id="right-pane" class="split split-horizontal">
    <div id="editor" class="split">
      <div id="editor-bar">
        <h1 class="label mdc-typography--headline6">Editor</h6>
        <button id="run-button" class="mdc-button mdc-button--outlined mdc-button--dense">Run</button>
      </div>
      <iframe id="blockly-area" class="split"></iframe>
    </div>
    <div id="console" class="split">
      <div id="console-bar">
        <h1 class="label mdc-typography--headline6">Console</h6>
      </div>
      <div id="console-entries">
        <p>> Use the "Print" block to write to this console!</p>
      </div>
    </div>
  </div>
  <div id="blockly-div" style="position: absolute;"></div>
  <xml id="toolbox" style="display: none">
    {% for group, blocks in special_groups|dictsort -%}
    <category name="{{group}}">
      {% for type, block in blocks|dictsort -%}
      <block type="{{type}}"></block>
      {%- endfor %}
    </category>
    {%- endfor %}
    <sep></sep>
    {% for group, blocks in algorithm_groups|dictsort -%}
    <category name="{{group}}">
      {% for type, block in blocks|dictsort -%}
      <block type="{{type}}"></block>
      {%- endfor %}
    </category>
    {%- endfor %}
  </xml>
  <script>
    {%- autoescape false -%}
    {%- for group, blocks in all_groups|dictsort -%}
    {% for type, block in blocks|dictsort %}
    Blockly.Blocks["{{type}}"] = {
      init: function() {
        this.jsonInit({{json.dumps(block, sort_keys=True)}});
      }
    };
    {%- endfor %}
    {%- endfor %}
    {%- endautoescape %}
  </script>

  <script src="/static/js/init.js"></script>
  <script src="/static/js/build.js"></script>
  <script>
    var xml = Blockly.Xml.textToDom(''
      + '<xml>'
      + '  <block type="Print">'
      + '    <value name="value">'
      + '      <block type="String">'
      + '        <field name="value">text</field>'
      + '      </block>'
      + '    </value>'
      + '  </block>'
      + '  <block type="Map.addLayer" x="10" y="50">'
      + '    <value name="object">'
      + '      <block type="Image.constant">'
      + '        <value name="value">'
      + '          <block type="Number">'
      + '            <field name="value">0</field>'
      + '          </block>'
      + '        </value>'
      + '      </block>'
      + '    </value>'
      + '  </block>'
      + '  <block type="Map.addLayer" x="10" y="115">'
      + '    <value name="object">'
      + '      <block type="Image.load">'
      + '        <value name="id">'
      + '          <block type="String">'
      + '            <field name="value">users/saicheems/clusters</field>'
      + '          </block>'
      + '        </value>'
      + '        <value name="version">'
      + '          <block type="Number">'
      + '            <field name="value">-1</field>'
      + '          </block>'
      + '        </value>'
      + '      </block>'
      + '    </value>'
      + '  </block>'
      + '</xml>');
    Blockly.Xml.domToWorkspace(xml, workspace);

    var consoleEntries = document.getElementById("console-entries");
    document.getElementById("run-button").onclick = function() {
      clearConsole();
      clearMapLayers();

      var topBlocks = workspace.getTopBlocks();
      var layerCount = 0;

      for (var i = 0; i < topBlocks.length; i++) {
        if (topBlocks[i].type == "Print") {
          (function() {
            var expression = buildExpression(
              topBlocks[i].inputList[0].connection.targetBlock());
            var p = addConsoleEntry("Computing...");
            computeValue(expression)
              .then(response => response.json())
              .catch(error => console.error(error))
              .then(response => {
                changeConsoleEntryText(p, JSON.stringify(response["result"]));
                console.log(response);
              });
          })();
        } else if (topBlocks[i].type == "Map.addLayer") {
          layerCount++;
          (function(layerCount) {
            var expression = buildExpression(
              topBlocks[i].inputList[0].connection.targetBlock());
            var layerControlLi = createLayerControlLi(layerCount);
            layerControlUl.appendChild(layerControlLi);
            var checkbox = document.getElementById("layer-list-checkbox-item-" + layerCount);
            checkbox.disabled = true;
            checkbox.index = layerCount - 1;
            checkbox.onchange = function(checkbox) {
              toggleMapLayer(checkbox);
            };

            createMap(expression)
              .then(response => response.json())
              .catch(error => console.error(error))
              .then(response => {
                checkbox.imageMapType = addMapLayer(layerCount, response.name);
                checkbox.disabled = false;
                checkbox.checked = true;
                var event = document.createEvent("HTMLEvents");
                event.initEvent("change", false, true);
                checkbox.dispatchEvent(event);
                console.log(response);
              });
          })(layerCount);
        }
      }
    };

    var clearMapLayers = function() {
      while (layerControlUl.firstChild) {
        layerControlUl.removeChild(layerControlUl.firstChild);
      }
      map.overlayMapTypes.clear();
    }

    var addMapLayer = function(i, mapName) {
      var base = "http://localhost:5000/v1/" + mapName + "/tiles/";
      var imageMapType = new google.maps.ImageMapType({
        getTileUrl: function(coord, zoom) {
          return base + zoom + "/" + coord.x + "/" + coord.y;
        },
        tileSize: new google.maps.Size(256, 256)
      });
      return imageMapType;
    }

    var toggleMapLayer = function(e) {
      var checkbox = e.target;
      if (checkbox.checked == true) {
        map.overlayMapTypes.setAt(checkbox.index, checkbox.imageMapType);
      } else {
        map.overlayMapTypes.setAt(checkbox.index, null);
      }
    }

    var createLayerControlLi = function(i) {
      var template = document.createElement('template');
      template.innerHTML = ''
        + '<li class="mdc-list-item" role="checkbox">'
        + '  <span class="mdc-list-item__graphic">'
        + '    <div class="mdc-checkbox">'
        + '      <input type="checkbox"'
        + '             class="mdc-checkbox__native-control"'
        + '             id="layer-list-checkbox-item-' + i + '"/>'
        + '      <div class="mdc-checkbox__background">'
        + '        <svg class="mdc-checkbox__checkmark"'
        + '             viewBox="0 0 24 24">'
        + '          <path class="mdc-checkbox__checkmark-path"'
        + '                fill="none"'
        + '                d="M1.73,12.91 8.1,19.28 22.79,4.59"/>'
        + '        </svg>'
        + '        <div class="mdc-checkbox__mixedmark"></div>'
        + '      </div>'
        + '    </div>'
        + '  </span>'
        + '  <label class="mdc-list-item__text" for="layer-list-checkbox-item-' + i + '">' + "Layer " + i + '</label>'
        + '</li>';
      return template.content.firstChild;
    }

    var clearConsole = function() {
      // Removes all nodes after the first. I don't know why there are 3
      // children by default, but there are...
      while (consoleEntries.childNodes.length > 3) {
        consoleEntries.removeChild(consoleEntries.childNodes[3]);
      }
    }

    var addConsoleEntry = function(text) {
      var p = document.createElement("p");
      var node = document.createTextNode("> " + text);
      p.appendChild(node);
      consoleEntries.append(p);
      return p;
    }

    var changeConsoleEntryText = function(p, text) {
      p.firstChild.nodeValue = "> " + text;
    }

    var computeValue = function(expression) {
      return fetch("http://localhost:5000/v1/value:compute", {
        method: "POST",
        body: JSON.stringify({"expression": expression}),
        headers: {
          "Content-Type": "application/json",
          "Access-Control-Allow-Origin": "*"
        }
      });
    }

    var createMap = function(expression) {
      return fetch("http://localhost:5000/v1/projects/earthengine-legacy/maps", {
        method: "POST",
        body: JSON.stringify({
          "expression": expression,
          "fileFormat": "PNG",
          "visualizationOptions": {}
        }),
        headers: {
          "Content-Type": "application/json",
          "Access-Control-Allow-Origin": "*"
        }
      });
    }
  </script>
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCSekB1BgBF1DYbMYMVKuIuVTP3sDjzkhs&callback=initMap" async defer></script>
</body>
</html>
